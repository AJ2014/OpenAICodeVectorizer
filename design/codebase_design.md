# 代码设计文档：增强型代码分析与问答系统

**版本:** 0.1
**日期:** 2023-10-27

## 目录

1.  [引言](#1-引言)
2.  [当前系统架构 (`src` 目录)](#2-当前系统架构-src-目录)
    *   [2.1. `rag_service.py`](#21-rag_servicepy)
    *   [2.2. `embedding_service.py`](#22-embedding_servicepy)
    *   [2.3. `utils.py`](#23-utilspy)
    *   [2.4. `visualize.py`](#24-visualizepy)
    *   [2.5. `__init__.py`](#25-__init__py)
3.  [拟议的增强功能与架构](#3-拟议的增强功能与架构)
    *   [3.1. 核心思想：引入工具调用和多轮交互能力](#31-核心思想引入工具调用和多轮交互能力)
    *   [3.2. 新增/修改模块](#32-新增修改模块)
        *   [3.2.1. `orchestrator.py` (新增)](#321-orchestratorpy-新增)
        *   [3.2.2. `tool_manager.py` (新增)](#322-tool_managerpy-新增)
        *   [3.2.3. `prompt_engine.py` (新增或整合入 `orchestrator.py`)](#323-prompt_enginepy-新增或整合入-orchestratorpy)
        *   [3.2.4. `embedding_service.py` (修改)](#324-embedding_servicepy-修改)
        *   [3.2.5. `rag_service.py` (修改/逐步替代)](#325-rag_servicepy-修改逐步替代)
    *   [3.3. 增强的工具集](#33-增强的工具集)
        *   [3.3.1. 高级向量数据库查询工具](#331-高级向量数据库查询工具)
        *   [3.3.2. 源代码工程文件系统交互工具](#332-源代码工程文件系统交互工具)
    *   [3.4. 模块化和动态提示工程](#34-模块化和动态提示工程)
4.  [高级交互流程示例](#4-高级交互流程示例)
5.  [代码重构与开发计划](#5-代码重构与开发计划)
    *   [5.1. 阶段一：基础工具与提示增强](#51-阶段一基础工具与提示增强)
    *   [5.2. 阶段二：编排器初步实现与工具集成](#52-阶段二编排器初步实现与工具集成)
    *   [5.3. 阶段三：高级查询与复杂任务支持](#53-阶段三高级查询与复杂任务支持)
    *   [5.4. 阶段四：(可选) 代码修改与安全写入工具](#54-阶段四可选-代码修改与安全写入工具)
    *   [5.5. 持续关注点](#55-持续关注点)

---

## 1. 引言

本文档旨在为 `OpenAICodeVectorizer` 项目设计一套增强方案，目标是将其从一个单轮的、基于RAG的问答系统，升级为一个能够进行更复杂代码分析、支持多轮交互、并能主动利用多种工具来获取信息的智能代码助手。该方案基于对现有 `src` 目录下代码的分析，并结合了对未来能力的展望。

## 2. 当前系统架构 (`src` 目录)

当前系统主要由以下几个模块构成：

### 2.1. `rag_service.py`

-   **功能**: 作为当前RAG问答的核心服务。接收用户问题，调用 `EmbeddingService` 检索相关代码片段作为上下文，然后构建Prompt，最后请求OpenAI LLM生成答案。
-   **限制**: 目前是单轮对话，上下文构建依赖于单次向量检索，Prompt模板相对固定。

### 2.2. `embedding_service.py`

-   **功能**: 负责代码库的嵌入索引和向量查询。
    -   `index_codebase`: 遍历源代码目录，读取文件，使用`RecursiveCharacterTextSplitter`和`tiktoken`进行文本分块，计算哈希以跳过未更改文件，通过配置的嵌入模型（支持Volcano、OpenAI）生成向量，并存储到ChromaDB持久化数据库。支持`.gitignore`。
    -   `query_vector_db`: 根据查询文本从ChromaDB中检索最相关的`n`个文档块。
-   **优点**: 功能较为完善，支持多种嵌入API和策略，有持久化存储和变更检测。

### 2.3. `utils.py`

-   **功能**: 提供辅助函数，如 `load_config()` 加载配置文件。

### 2.4. `visualize.py`

-   **功能**: (推测) 可能用于可视化代码嵌入、代码结构或分析结果。此模块的具体增强不在本文档主要讨论范围内，但其输出可作为未来工具的潜在信息源。

### 2.5. `__init__.py`

-   **功能**: Python包初始化文件。

## 3. 拟议的增强功能与架构

核心思路是通过引入**工具（Tools）**的概念和**编排器（Orchestrator）**来赋予LLM更强的自主性和解决复杂问题的能力。LLM不再仅仅是被动地根据检索到的上下文回答问题，而是可以主动请求调用工具来获取额外信息或执行操作。

### 3.1. 核心思想：引入工具调用和多轮交互能力

系统将演变为一个能够与LLM进行多轮“对话”的模式。LLM在接收到用户问题和初步上下文后，可以分析信息是否充足，如果不足，它可以请求调用一个或多个预定义的工具。工具执行结果将返回给LLM，形成新的上下文，LLM基于此再次决策，直至能够回答用户问题或完成任务。

### 3.2. 新增/修改模块

#### 3.2.1. `orchestrator.py` (新增)

-   **职责**: 作为系统的总控制中心。
    -   管理与LLM的多轮交互。
    -   解析LLM的输出，判断是最终答案还是工具调用请求。
    -   根据LLM的请求，调用 `ToolManager` 中的相应工具。
    -   收集工具执行结果，并将其反馈给LLM。
    -   维护对话历史和上下文状态。
    -   集成 `PromptEngine` 来动态构建发送给LLM的提示。

#### 3.2.2. `tool_manager.py` (新增)

-   **职责**: 注册和管理所有可供LLM调用的工具。
    -   提供一个统一的接口供 `Orchestrator` 调用工具。
    -   包含下述3.3节中定义的工具实现或其调用封装。

#### 3.2.3. `prompt_engine.py` (新增或整合入 `orchestrator.py`)

-   **职责**: 负责动态构建和管理LLM的提示模板。
    -   支持模块化提示组件（系统角色、任务指令、上下文格式化、工具使用说明等）。
    -   根据当前任务类型和对话状态选择或生成合适的提示。
    -   将工具的可用性及其描述注入提示，以便LLM知晓可以调用哪些工具以及如何调用。

#### 3.2.4. `embedding_service.py` (修改)

-   **修改点**:
    -   增强 `query_vector_db` 方法，支持更细致的查询参数，如：
        -   动态调整 `n_results`。
        -   基于元数据进行过滤（例如，文件类型、特定子目录下的文件、更新日期等，前提是这些元数据在索引时已存储）。
    -   考虑提供一个接口，允许按文件路径精确获取其所有已索引的chunks，而不仅仅是相似度搜索。

#### 3.2.5. `rag_service.py` (修改/逐步替代)

-   **初期**: `RAGService` 的 `answer_question` 方法可以被 `Orchestrator` 作为初始信息获取步骤调用。
-   **远期**: 其功能可能被 `Orchestrator`、`ToolManager`（向量查询工具）、和 `PromptEngine` 更灵活的组合所替代。

### 3.3. 增强的工具集

这些工具将注册到 `ToolManager` 中。

#### 3.3.1. 高级向量数据库查询工具

-   **接口示例**: `query_vector_db(query_text: str, n_results: int, filters: dict = None) -> List[DocumentChunk]`
-   **功能**: 允许LLM根据需要调整检索的上下文数量，并根据元数据（如文件名、路径、标签等）进行过滤，以获取更精确的上下文。
-   **调用场景**: 当LLM认为初步检索的上下文不充分或需要特定文件的信息时。

#### 3.3.2. 源代码工程文件系统交互工具

##### a. 列举目录内容工具 (`list_directory`)

-   **接口示例**: `list_directory(path: str, recursive: bool = False) -> List[str]`
-   **功能**: 列出指定项目路径下的文件和子目录。
-   **调用场景**: 当LLM需要了解项目结构、某个模块包含哪些文件时。

##### b. 读取文件内容工具 (`read_file_content`)

-   **接口示例**: `read_file_content(file_path: str, start_line: int = None, end_line: int = None) -> str`
-   **功能**: 读取指定文件的全部或部分内容。
-   **调用场景**: 当向量数据库中的代码片段不足以理解完整逻辑，或LLM需要查看特定文件的具体实现时。

##### c. (高级/可选) 写入/修改文件工具 (`write_file`, `apply_diff`)

-   **功能**: 创建新文件、修改现有文件内容。
-   **重要**: 此类工具需极其谨慎地设计，具备严格的路径限制、内容校验和用户确认机制，以防安全风险。
-   **调用场景**: 用于代码生成、自动修复建议等高级任务。

### 3.4. 模块化和动态提示工程

-   **目的**: 使LLM能够理解其能力边界、可用资源，并引导其进行有效的问题分解和工具使用。
-   **实现**:
    -   **基础提示模板**: 包含系统角色、总体任务、用户问题。
    -   **工具描述注入**: 向LLM清晰描述每个可用工具的功能、输入参数和预期输出格式。例如："你可以使用 `read_file_content(file_path='path/to/file')` 来读取文件内容。"
    -   **上下文动态组合**: 将向量检索结果、文件读取结果、目录列表等工具输出，结构化地整合到后续的提示中。
    -   **任务特定模板**: 为不同类型的代码分析任务（如“解释这段代码”、“找到潜在的bug”、“重构建议”）设计专门的提示结构和引导语。
    -   **链式思考 (Chain-of-Thought) 引导**: 鼓励LLM在复杂问题上逐步思考，并将思考过程和工具选择的理由也展示出来（或在内部记录）。

## 4. 高级交互流程示例

1.  **用户提问**: "项目中的 `EmbeddingService` 是如何处理增量索引的？请结合 `index_codebase` 方法说明。"
2.  **Orchestrator**:
    *   使用 `PromptEngine` 构建初始提示，包含用户问题和工具列表。
    *   调用LLM。
3.  **LLM (第一轮)**:
    *   (思考) "用户问及增量索引和 `index_codebase`。我需要先从向量数据库获取相关信息。"
    *   (输出) `ACTION: query_vector_db(query_text="EmbeddingService index_codebase incremental indexing file hash", n_results=5)`
4.  **Orchestrator**:
    *   解析到工具调用请求。
    *   调用 `ToolManager.execute_tool('query_vector_db', ...)`。
    *   获取到5个代码片段。
    *   使用 `PromptEngine` 构建包含这些片段的新提示。
    *   再次调用LLM。
5.  **LLM (第二轮)**:
    *   (思考) "这些片段提到了 `_get_file_hash` 和跳过已索引文件。但我想确认 `index_codebase` 中具体是如何使用哈希值比较的，以及如何处理已更改的文件。原始代码片段可能不完整。我需要查看 `embedding_service.py` 中 `index_codebase` 方法的完整实现，特别是涉及文件哈希比较和更新的部分。"
    *   (输出) `ACTION: read_file_content(file_path="src/embedding_service.py")` (或者更精确地指定行号范围，如果LLM能从元数据推断)
6.  **Orchestrator**:
    *   调用 `ToolManager.execute_tool('read_file_content', ...)`。
    *   获取文件内容。
    *   构建包含文件内容的新提示。
    *   再次调用LLM。
7.  **LLM (第三轮)**:
    *   (思考) "现在我有了完整的代码。可以看到 `index_codebase` 中计算 `current_file_hash`，然后从数据库查询 `existing_doc`，比较 `existing_doc['metadatas'][0].get('file_hash')` 和 `current_file_hash`。如果相同则跳过。如果文件已更改或新文件，则会删除旧的文档（如果存在）并添加新的文档块。"
    *   (输出) `FINAL_ANSWER: EmbeddingService 通过文件内容的MD5哈希值实现增量索引。在 index_codebase 方法中，它会...（详细解释）...。对于已更改的文件，它会先删除旧的向量记录，再添加新的记录。`
8.  **Orchestrator**: 返回最终答案给用户。

## 5. 代码重构与开发计划

### 5.1. 阶段一：基础工具与提示增强

-   **目标**: 实现基本的文件读取和目录列举工具，改进 `RAGService` 的提示机制。
-   **任务**:
    1.  创建 `tool_manager.py`：
        *   定义工具基类或接口。
        *   实现 `list_directory` 工具。
        *   实现 `read_file_content` 工具 (可先放在 `utils.py` 中，由 `tool_manager` 调用)。
    2.  修改 `rag_service.py` (或开始构建 `prompt_engine.py` 的雏形):
        *   将现有Prompt模板化，方便后续扩展。
        *   实验性地在Prompt中加入对新工具的简单描述。
        *   修改 `answer_question`，使其能够接收更灵活的向量查询参数（如 `n_results`）。
    3.  修改 `embedding_service.py`:
        *   确保 `query_vector_db` 可以灵活接受 `n_results`。
    4.  **单元测试**: 为新工具编写单元测试。

### 5.2. 阶段二：编排器初步实现与工具集成

-   **目标**: 搭建 `Orchestrator` 的基本框架，使其能够进行简单的工具调用。
-   **任务**:
    1.  创建 `orchestrator.py`:
        *   实现一个基本的主循环，可以调用LLM。
        *   实现LLM响应的解析逻辑，能够识别简单的工具调用指令（例如，LLM输出特定格式的字符串如 `TOOL_CALL: tool_name(arg1=value1)`）。
        *   集成 `ToolManager`，根据解析结果调用相应工具。
        *   将工具执行结果简单地追加到上下文中，再次调用LLM。
    2.  创建 `prompt_engine.py` (如果未在阶段一完成):
        *   设计更完善的提示结构，明确包含工具描述和使用方法的部分。
    3.  **集成测试**: 测试 `Orchestrator` -> `LLM` -> `ToolManager` -> `Tool` -> `LLM` 的基本流程。

### 5.3. 阶段三：高级查询与复杂任务支持

-   **目标**: 增强向量查询能力，支持更复杂的任务和提示策略。
-   **任务**:
    1.  修改 `embedding_service.py`:
        *   为 `query_vector_db` 增加基于元数据的过滤功能。确保索引时存储了必要的元数据（如文件名，文件类型）。
    2.  更新 `ToolManager`：暴露这个增强的向量查询工具。
    3.  增强 `PromptEngine`:
        *   开发针对不同代码分析任务（解释、调试、摘要等）的特定提示模板。
        *   引入更复杂的上下文管理，如对话历史摘要。
        *   研究并实现链式思考 (Chain-of-Thought) 或 ReAct 等提示策略的引导。
    4.  完善 `Orchestrator`:
        *   处理更复杂的工具调用逻辑和多轮对话状态。
        *   增强错误处理和回退机制。

### 5.4. 阶段四：(可选) 代码修改与安全写入工具

-   **目标**: (如果需要) 审慎地引入代码修改能力。
-   **任务**:
    1.  设计安全的 `write_file_content` 或 `apply_diff` 工具。
        *   严格的路径校验（限制在项目工作区内）。
        *   内容变更预览机制。
        *   用户确认步骤。
    2.  在 `ToolManager` 中注册这些工具。
    3.  在 `PromptEngine` 中加入对这些工具的描述和使用约束。
    4.  **严格的安全审计和测试。**

### 5.5. 持续关注点

-   **配置管理 (`config.yml`)**: 随功能增加，及时更新配置文件，使其能控制新模块的行为（如工具参数、LLM模型选择、提示模板路径等）。
-   **日志记录**: 在 `Orchestrator` 和 `ToolManager` 中添加详细日志，方便追踪多步操作和调试。
-   **错误处理**: 为工具执行失败、LLM API错误等情况设计健壮的错误处理和重试机制。
-   **测试**: 持续编写单元测试、集成测试，特别是针对多轮交互和工具使用的复杂场景。
-   **评估**: 设计评估方案，衡量增强后的系统在代码理解、问题解答和任务完成能力上的提升。